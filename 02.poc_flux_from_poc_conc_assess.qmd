---
title: "Predict POC flux from POC concentration profile"
subtitle: "Assess RF model to predict POC flux from POC concentration profile and sediment trap depth."
author: "Thelma Panaïotis"
format:
  html:
    toc: true
    toc-depth: 3
    embed-resources: true
editor: visual
cache: true
---

## Set-up and load data

```{r set_up}
#| output: false
source("utils.R")
load("data/01.predictions.Rdata")
```

## Model evaluation

Get R²  values and plot them.

```{r rsq}
# Unnest predictions
preds <- res %>% select(fold, cv_type, preds) %>% unnest(preds)

# Compute Rsquare for each fold
rsquares <- preds %>%
  group_by(cv_type, fold) %>%
  rsq(truth = log_poc_flux, estimate = .pred)

# Distribution of Rsquares by CV type
rsquares %>% split(.$cv_type) %>% map(summary)

# Plot Rsquares values
ggplot(rsquares) + 
  geom_boxplot(aes(x = cv_type, y = .estimate, group = cv_type, colour = cv_type)) +
  geom_jitter(aes(x = cv_type, y = .estimate), size = 0.5, width = 0.1) +
  scale_y_continuous(limits = c(0, 1), expand = c(0, 0)) +
  labs(x = "CV type", y = "R²", colour = "CV type")
```

## Model interpretation

### Variable importance

```{r var_imp}
# Unnest variable importance
full_vip <- res %>%
  select(cv_type, fold, importance) %>%
  unnest(importance) %>%
  mutate(variable = forcats::fct_reorder(variable, dropout_loss))

# Average across folds
full_vip %>%
  filter(variable != "_full_model_") %>%
  group_by(cv_type, fold, variable) %>%
  summarise(dropout_loss = mean(dropout_loss), .groups = "drop") %>%
  ggplot() +
  geom_vline(data = full_vip %>% filter(variable == "_full_model_"), aes(xintercept = mean(dropout_loss)), colour = "grey", linewidth = 2) +
  geom_boxplot(aes(x = dropout_loss, y = variable, colour = cv_type)) +
  labs(x = "Mean RMSE after permutations across CV folds")
```

### Partial dependence plots

```{r pdp}
# Variables for which to plot pdp
n_pdp <- 3
vars_pdp <- full_vip %>%
  filter(variable != "_full_model_") %>%
  mutate(variable = as.character(variable)) %>%
  group_by(cv_type, variable) %>%
  summarise(dropout_loss = mean(dropout_loss), .groups = "drop") %>%
  arrange(desc(dropout_loss)) %>%
  group_by(cv_type) %>%
  slice_head(n = n_pdp)

# Unnest cp_profiles
cp_profiles <- res %>% select(cv_type, fold, cp_profiles) %>% unnest(cp_profiles)

## Let’s generate averaged cp profile across folds for each cv-type and propagating uncertainties. 
## The difficulty is that x values differ between each fold, the solution is to interpolate yhat on a common set of x values across folds.
## Steps as follows for each cv_type and each variable
## 1- compute the mean and spread of cp profiles within each fold
## 2- interpolate yhat value and spread within each fold using a common set of x values
## 3- perform a weighted average of yhat value and spread, using 1/var as weights

# Get names of folds, for later use
folds <- sort(unique(full_vip$fold))

# Apply on each cv_type and variable
mean_pdp <- lapply(1:nrow(vars_pdp), function(r){
  
  # Get variable and cvtype
  var_name <- vars_pdp[r,]$variable
  cv_type_name <- vars_pdp[r,]$cv_type
  
  ## Get corresponding CP profiles, compute mean and spread for each fold (step 1)
  d_pdp <- cp_profiles %>% 
    filter(cv_type == cv_type_name & `_vname_` == var_name) %>% 
    select(cv_type, fold, `_yhat_`, `_vname_`, `_ids_`, all_of(var_name)) %>% 
    arrange(`_ids_`, across(all_of(var_name))) %>% 
    # center each cp profiles across fold, variable and ids
    group_by(cv_type, fold, `_vname_`, `_ids_`) %>%
    mutate(yhat_cent = `_yhat_` - mean(`_yhat_`)) %>% # center cp profiles
    ungroup() %>%
    # compute mean and sd of centered cp profiles for each fold and value of the variable of interest
    group_by(cv_type, fold, across(all_of(var_name))) %>%
    summarise(
      yhat_loc = mean(`_yhat_`), # compute mean of profiles
      yhat_spr = sd(yhat_cent), # compute sd of cp profiles
      .groups = "keep"
    ) %>%
    ungroup() %>% 
    setNames(c("cv_type", "fold", "x", "yhat_loc", "yhat_spr"))
  
  ## Interpolate yhat values and spread on a common x distribution (step 2)
  # Regularise across folds: need a common x distribution, and interpolate y on this new x
  new_x <- quantile(d_pdp$x, probs = seq(0, 1, 0.01), names = FALSE)
  # x is different within each fold, so interpolation is performed on each fold
  
  int_pdp <- lapply(1:length(folds), function(i){
    # Get data corresponding to this fold
    fold_name <- folds[i]
    this_fold <- d_pdp %>% filter(fold == fold_name)
    
    # Extract original x values
    x <- this_fold$x
    # Extract values to interpolate (yhat_loc and yhat_spr)
    yhat_loc <- this_fold$yhat_loc
    yhat_spr <- this_fold$yhat_spr
    # Interpolate yhat_loc and yhat_spr on new x values
    int <- tibble(
      #x = new_x,
      yhat_loc = castr::interpolate(x = x, y = yhat_loc, xout = new_x),
      yhat_spr = castr::interpolate(x = x, y = yhat_spr, xout = new_x),
    ) %>% 
      mutate(
        x = new_x,
        cv_type = cv_type_name,
        fold = fold_name,
        var_name = var_name
      ) %>% 
      select(x, everything())
    # Return the result
    return(int)
    
  }) %>% 
    bind_rows()
  
  ## Across fold, compute the weighted mean, using 1/var as weights (step 3)
  mean_pdp <- int_pdp %>% 
    group_by(cv_type, var_name, x) %>% 
    summarise(
      yhat_loc = wtd.mean(yhat_loc, weights = 1/(yhat_spr)^2),
      yhat_spr = wtd.mean(yhat_spr, weights = 1/(yhat_spr)^2),
      .groups = "drop"
    ) %>% 
    arrange(x)
  
  # Return the result
  return(mean_pdp)
}) %>% 
  bind_rows()

# Arrange in order of most important variables
mean_pdp <- vars_pdp %>% 
  rename(var_name = variable) %>% 
  left_join(mean_pdp, by = join_by(cv_type, var_name)) %>% 
  mutate(var_name = fct_inorder(var_name)) %>% 
  select(-dropout_loss)

# Plot it!
ggplot(mean_pdp) + 
  geom_path(aes(x = x, y = yhat_loc, colour = cv_type)) +
  geom_ribbon(aes(x = x, ymin = yhat_loc - yhat_spr, ymax = yhat_loc + yhat_spr, fill = cv_type), alpha = 0.2) +
  facet_wrap(~var_name, scales = "free_x")
```

## New predictions

Map POC flux at 1000 m.

### Collect predictons

```{r collect_preds}
# Unnest new predictions (i.e. projections)
new_preds <- res %>% 
  select(fold, cv_type, new_preds) %>% 
  unnest(new_preds) %>% 
  select(cv_type, fold, lon, lat, contains("poc"))

# Get those from stratified CV
new_preds_strat <- new_preds %>% filter(cv_type == "stratified")

# Join projections with R² value for each fold and each cv_type.
new_preds_strat <- new_preds_strat %>% left_join(rsquares %>% select(cv_type, fold, rsq = .estimate), by = join_by(cv_type, fold))

## Average by pixel
# Stratified
strat_proj <- new_preds_strat %>% 
  group_by(lon, lat) %>% 
  summarise(
    poc_flux_avg = wtd.mean(pred_poc_flux, weights = rsq, na.rm = TRUE), 
    poc_flux_sd = sqrt(wtd.var(pred_poc_flux, weights = rsq, na.rm = TRUE)), 
    .groups = "drop"
    )

# Generate common colour bar limits for both CV types
poc_flux_avg_lims <- c(
  min(c(strat_proj$poc_flux_avg)), 
  max(c(strat_proj$poc_flux_avg))  
)
poc_flux_sd_lims <- c(
  min(c(strat_proj$poc_flux_sd)), 
  max(c(strat_proj$poc_flux_sd))  
)
```

### Maps

```{r map_pred}
#| fig-column: body-outset
#| out-width: 100%

ggplot(strat_proj) + 
  geom_polygon(data = world, aes(x = lon, y = lat, group = group), fill = "grey") +
  geom_tile(aes(x = lon, y = lat, colour = poc_flux_avg, fill = poc_flux_avg)) + 
  scale_fill_cmocean(name = "speed", limits = poc_flux_avg_lims) +
  scale_colour_cmocean(name = "speed", limits = poc_flux_avg_lims) +
  labs(
    title = "POC flux avg at 1000 m from stratified CV", 
    fill = "POC flux<br>(mg m<sup>-2</sup> d<sup>-1</sup>)",
    colour = "POC flux<br>(mg m<sup>-2</sup> d<sup>-1</sup>)"
    ) +
  coord_quickmap(expand = 0) +
  theme(legend.title = element_markdown())
```

```{r map_sd}
#| fig-column: body-outset
#| out-width: 100%

ggplot(strat_proj) + 
  geom_polygon(data = world, aes(x = lon, y = lat, group = group), fill = "grey") +
  geom_tile(aes(x = lon, y = lat, colour = poc_flux_sd, fill = poc_flux_sd)) + 
  ggplot2::scale_fill_viridis_c(option = "E", limits = poc_flux_sd_lims) +
  ggplot2::scale_colour_viridis_c(option = "E", limits = poc_flux_sd_lims) +
  labs(
    title = "POC flux sd at 1000 m from stratified CV", 
    fill = "POC flux<br>sd<br>(mg m<sup>-2</sup> d<sup>-1</sup>)",
    colour = "POC flux<br>sd<br>(mg m<sup>-2</sup> d<sup>-1</sup>)"
    ) +
  coord_quickmap(expand = 0) +
  theme(legend.title = element_markdown())
```
